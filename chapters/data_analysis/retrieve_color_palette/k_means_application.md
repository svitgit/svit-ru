---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.14.5
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Применение K-means

## Введение
Всем привет.
Сегодня рассмотрим возможный пример применения метода кластеризации `k-means`.
Предлагаю применить метод для кластеризации изображения.
В качестве примера, рассмотрим данный кадр из фильма:
```{image} ./pics/barbie.jpg
:width: 720px
:align: center
```

При помощи применения метода `k-means` мы научимся по изображению определять цветовую палитру.
В целом ты можешь задаться вопросом, а зачем.
Например, для меня цветовые палитры фильмов служат вдохновением для создания своих собственных кадров.
Да и в целом, цветовые палитры могут позволить улучшить рассказ историй посредством визуала или помочь создавать визуально привлекательные дизайны.
В подтверждение своих слов хочу привести примеры ресурсов, которые только и делают, что специализируются на подборе цветовых палитр.
Например, сайт [coolors](https://coolors.co/) или сайт [adobe.color](https://color.adobe.com/create/color-wheel).
Как ты видишь, всё это позволяет профессионалам из различных творческих областей перенимать мастерство кинематографистов и применять эти принципы в своей собственной работе, в результате чего получаются уникальные и визуально привлекательные творения.
```{image} ./pics/image_representation.gif
:width: 720px
:align: center
```

Если ты смотрел мой предыдущий [ролик](https://youtu.be/8WQOFRFdLao), то ты помнишь, что в качестве исходных данных у нас были точки на плоскости.
Поэтому нам требуется каким-то образом свести картинку к набору точек в пространстве.

## Представление изображений
Для этого сначала рассмотрим, что же из себя представляет изображение.
Прямо сейчас ты смотришь на экран своего устройства.
В действительности, если рассмотреть экран вблизи, то можно обнаружить, что он состоит из множества миниатюрных элементов - физических элементов матрицы дисплея.
Зачастую - это набор элементов, которые светятся в трех диапазонах: красный, зеленый и голубой.
Т.е. в таком случае любое изображение - это наложение комбинаций трех цветов, которые позволяют получать всевозможные остальные цвета и оттенки.
Ок, но как же мы можем хранить информацию об этом в нашем компьютере?
Давай абстрактно выделим тройку разноцветных элементов в группу и назовем пикселем.
В таком случае мы можем сказать, что любое изображение представляет собой многомерный массив, а именно масив размерности `(h, w, c)`, где `h` - высота, `w` - ширина и `c` - число цветов.

```{image} ./pics/pixels.gif
:width: 720px
:align: center
```

## Разворачивание изображения
Собственно, таким образом зачастую изображения и представлены в языках программирования.
Однако, для нашей задачи такое представление является слегка усложненным.
Мы имеем трехмерный массив, а нам хотелось бы иметь информацию в виде двухмерного массива размерности: `(h * w, c)`, т.е. в виде таблицы, с тремя столбцами и числом строк соответствующему числу всех пикселей.
В таком случае получилось бы, что каждый пиксель представляет собой точку в трехмерном пространстве, где первая координата соответствует интенсивности красного цвета, вторая - интенсивности зеленого и последняя координата отвечает за интенсивность синего цвета.

Сделать это не так сложно, давай просто возьмем каждый двумерный массив для каждого цвета и уложим его в одномерный массив.
Выглядит это как-то так, мы берем все строчки и разворачиваем их в ряд.
Ок, после этого мы имеем данные, которые готовы к кластеризации.
Теперь перейдем к процессу написания, нашей программы.

```{image} ./pics/array_representation.gif
:width: 720px
:align: center
```

## Настройка окружения

Начнём как и в предыдущем ролике с настройки окружения для нашей сегодняшней работы.
Создадим папку и виртуальное окружение в ней:
```bash
python -m venv ./kmeans_application
```

Активируем виртуальное окружение:
```bash
source ./kmeans_application/bin/activate
```

Установим все необходимые библиотеки:
```bash
pip install numpy matplotlib scikit-image scikit-learn
```

Также я создам папку `pics` и помещу в него наше изображение.


## Загрузка библиотек

Я создам файл `kmeans.py`.
Начнем с загрузки необходимых библиотек:

```{code-cell} ipython3
import numpy as np
import matplotlib.pyplot as plt

from skimage import io
from skimage.color import rgb2lab, lab2rgb
from sklearn.cluster import MiniBatchKMeans
```

## Чтение и отображение изображения
В Python существует множество библиотек для работы с изображениями.
В качестве примера я сегодня рассмотрю процесс работы с изображениями за счёт использования библиотеки `skimage`.
Воспользуемся модулем `io` для чтения изображения:
```{code-cell} ipython3
img = io.imread("./pics/barbie.jpg")
```

Мы можем отобразить наше изображения при помощи функци `imshow`:
```{code-cell} ipython3
plt.imshow(img)
plt.gca().axis("off")
plt.show()
```

Также можно узнать размерность нашего изображения следующим образом:
```{code-cell} ipython3
print(img.shape)
```
В данном случае наша картинка имеет высоту 2400 пикселей и ширину 3600 пикселей.

Давай для начала рассмотрим как выглядит индивидуальный цветовой канал, данного изображения:
```{code-cell} ipython3
r_channel, g_channel, b_channel = [img[:, :, i] for i in range(3)]
```
После выполнения данного кода в переменные `r_channel`, `g_channel` и `b_channel` будут записаны двумерные массивы, которые определяют тройку цветов.

Для отображения их воспользуемся следующим кодом:
```{code-cell} ipython3
pics, axs = plt.subplots(ncols=3, figsize = (12, 5))

axs[0].imshow(r_channel, cmap="Reds")
axs[0].axis("off")

axs[1].imshow(g_channel, cmap="Greens")
axs[1].axis("off")

axs[2].imshow(b_channel, cmap="Blues")
axs[2].axis("off")
```
Так выглядит разложение картинки в тройку цветов.

## Кластеризация изображения
Отлично, теперь перейдем непосредственно к процессу кластеризации.
Для начала, я хочу перевести изображение из `rgb`-пространства в `lab`-пространство.
Тут я не хочу сильно вдаваться в подробности, однако существуют различные способы представления изображений.
Хочу лишь привести аналогию с различными формами записями числа, где использование различных систем исчисления приводит к различным видам записи одного и того же числа.
При этом могут существовать различные преимущества в различных формах записи. 
Так и здесь, различные цветовые пространства обладают различными свойствами.
Далее меня будет интересовать `lab`-пространство, так как расстояния между точками в этом пространстве лучше соответствуют человеческому восприятию цветов.
Итак переведем изображения в `lab`-пространство и переведем данные из трехмерного массива в двухмерный:
```{code-cell} ipython3
lab_img = rgb2lab(img)
flat_img = lab_img.reshape((-1, 3))
print(flat_img.shape)
```
Для кластеризации в данном ролике, я буду пользоваться готовой реализацией метода `k-means` библиотеки `sklearn`, а именно `MiniBatchKMeans`:
```{code-cell} ipython3
:tags: ["hide-output"]
nc = 8
km = MiniBatchKMeans(n_clusters=nc, random_state=42, batch_size=2**15, n_init=10)
km.fit(flat_img)
```
Здесь мы определяем число кластеров `nc` и после этого применяем метод `MiniBatchKMeans` для нашего изображения.

## Центры изображения

Как ты помнишь на каждом шаге метода кластеризации `k-means` определяются центры кластеров.
Для наших данных центры представляют собой точки в трехмерном пространстве, которые являются средним цветом для каждого кластера.
То есть, в данном случае мы имеем 8 различных цветов, которые хорошим образом описывают наиболее специфичные цвета нашей картинки.
В действительности, эти цвета можно рассматривать как цветовую палитру, характеризующую текущий кадр.
Давай нарисуем цветовую палитру, полученную для нашего кадра.
Для начала сохраним, полученные центры, в отдельную переменную:

```{code-cell} ipython3
centers = [col for col in km.cluster_centers_]
```
Здесь я записываю центры в переменную `centers` и после этого сортирую `centers`, чтобы визуально наиболее похожие цвета располагались рядом друг с другом:

```{code-cell} ipython3
centers = sorted(centers, key=lambda clrs: list(clrs))
```

Теперь нарисуем нашу цветовую палитру:
```{code-cell} ipython3
palette = [lab2rgb(np.full((100, 100, 3), color)) for color in centers]
palette = np.concatenate(palette, axis=1)

pics = plt.figure(figsize=(7, 2))
plt.imshow(palette)
plt.gca().axis("off")
plt.show()
```


## Лейблы кластеризации

Мы можем помимо центров действительно закластеризовать все пиксели, то есть присвоить им лейблы.
Для этого выполним следующий код:
```{code-cell} ipython3
labels = km.predict(flat_img)
print(labels[:10])
```
То есть в нашем случае, например, первые десять пикселей соответствуют кластеру с индексом `4`.

Также мы можем создать изображение в котором каждый пиксель будет заменен цветом ближайшего центра:
```{code-cell} ipython3
km_img = np.apply_along_axis(lambda x: km.cluster_centers_[x], 0, labels)

# преобразуем изображение обратно к трехмерному массиву
km_img = km_img.reshape(img.shape)

pics = plt.figure(figsize=(8, 8))
plt.imshow(lab2rgb(km_img))
plt.gca().axis("off")
plt.show()
```
Чем-то похоже на работы Энди Уорхола неправда ли?
Из данного примера видно, что применение `k-means` может быть использовано для сжатия изображения.
Также в ряде задач в области машинного обучения бывает полезно провести такое преобразование изображения, оставив лишь наиболее важные элемент изображения с последующим их анализом.

На этом на сегодня всё.
Как и всегда, я с радостью готов помочь разобраться со сложностями, которые могли возникнуть при просмотре сегодняшнего эпизода.
Просто дай мне об этом знать в комментариях или в телеграм-чате.
До скорой встречи, друг.